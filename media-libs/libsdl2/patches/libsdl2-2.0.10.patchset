From a51d4c9d46c33cb3e8980b78789a20329c0811bd Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Fri, 29 Aug 2014 15:24:11 +0000
Subject: haiku patch

---
 src/video/haiku/SDL_bopengl.cc | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/video/haiku/SDL_bopengl.cc b/src/video/haiku/SDL_bopengl.cc
index 5065e9f..44b21fe 100644
--- a/src/video/haiku/SDL_bopengl.cc
+++ b/src/video/haiku/SDL_bopengl.cc
@@ -54,7 +54,7 @@ int HAIKU_GL_LoadLibrary(_THIS, const char *path)
         if( get_image_symbol(info.id, "glBegin", B_SYMBOL_TYPE_ANY,
                 &location) == B_OK) {
 
-            _this->gl_config.dll_handle = (void *) (size_t) info.id;
+            _this->gl_config.dll_handle = (void *) (addr_t) info.id;
             _this->gl_config.driver_loaded = 1;
             SDL_strlcpy(_this->gl_config.driver_path, "libGL.so",
                     SDL_arraysize(_this->gl_config.driver_path));
@@ -69,7 +69,7 @@ void *HAIKU_GL_GetProcAddress(_THIS, const char *proc)
         void *location = NULL;
         status_t err;
         if ((err =
-            get_image_symbol((image_id) (size_t) _this->gl_config.dll_handle,
+            get_image_symbol((image_id) (addr_t) _this->gl_config.dll_handle,
                               proc, B_SYMBOL_TYPE_ANY,
                               &location)) == B_OK) {
             return location;
-- 
2.24.1

From 542b6358f9f1af6e0bcff7eeb3290968c3723b75 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Thu, 25 Feb 2016 20:23:41 +0000
Subject: remove nacl, missing templates on Haiku

---
 configure.ac | 27 ---------------------------
 1 file changed, 27 deletions(-)

diff --git a/configure.ac b/configure.ac
index 9e782c6..c0527a2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1520,33 +1520,6 @@ AS_HELP_STRING([--enable-wayland-shared], [dynamically load Wayland support [[de
 }
 
 
-dnl Check for Native Client stuff
-CheckNativeClient()
-{
-        AC_TRY_COMPILE([
-          #if !defined(__native_client__)
-          #error "NO NACL"
-          #endif
-        ],[
-        ],[
-        AC_DEFINE(SDL_VIDEO_DRIVER_NACL, 1, [ ])
-        AC_DEFINE(SDL_AUDIO_DRIVER_NACL, 1, [ ])
-        AC_DEFINE(HAVE_POW, 1, [ ])
-        AC_DEFINE(HAVE_OPENGLES2, 1, [ ])
-        AC_DEFINE(SDL_VIDEO_OPENGL_ES2, 1, [ ])
-        AC_DEFINE(SDL_VIDEO_RENDER_OGL_ES2, 1, [ ])
-
-        SDL_LIBS="-lppapi_simple -lppapi_gles2 $SDL_LIBS"
-
-        SDLMAIN_SOURCES="$srcdir/src/main/nacl/*.c"
-        SOURCES="$SOURCES $srcdir/src/audio/nacl/*.c"
-        SUMMARY_audio="${SUMMARY_audio} nacl"
-        SOURCES="$SOURCES $srcdir/src/video/nacl/*.c"
-        SUMMARY_video="${SUMMARY_video} nacl opengles2"
-        ])
-}
-
-
 CheckRPI()
 {
     AC_ARG_ENABLE(video-rpi,
-- 
2.24.1

From 6debcb339c5e6b30362ebba49656b46515211264 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Sat, 30 Sep 2017 13:36:12 +0200
Subject: fix AC_DEFINE

---
 configure.ac | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index c0527a2..166d06b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1823,7 +1823,7 @@ int event_type = XI_TouchBegin;
 XITouchClassInfo *t;
                     ],[
                     have_xinput2_multitouch=yes
-                    AC_DEFINE([SDL_VIDEO_DRIVER_X11_XINPUT2_SUPPORTS_MULTITOUCH], 1, [])
+		AC_DEFINE([SDL_VIDEO_DRIVER_X11_XINPUT2_SUPPORTS_MULTITOUCH], [], [Description])
                     SUMMARY_video_x11="${SUMMARY_video_x11} xinput2_multitouch"
                     ])
                 AC_MSG_RESULT($have_xinput2_multitouch)
-- 
2.24.1

From 4387b760fc4fd6275a01cee92628f8a93081de72 Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Fri, 2 Feb 2018 09:40:46 +0100
Subject: Fix secondary arch build.

Rather than trying to guess the name of libstdc++, run libtool in C++
mode so it figures this out by itself. The previous way of detecting
libstdc++ would not allow for building a secondary architecture package.
---
 Makefile.in  | 6 +++---
 configure.ac | 3 ---
 2 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 567624e..1c5622f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -147,13 +147,13 @@ update-revision:
 .PHONY: all update-revision install install-bin install-hdrs install-lib install-data uninstall uninstall-bin uninstall-hdrs uninstall-lib uninstall-data clean distclean dist $(OBJECTS:.lo=.d)
 
 $(objects)/$(TARGET): $(GEN_HEADERS) $(GEN_OBJECTS) $(OBJECTS) $(VERSION_OBJECTS)
-	$(RUN_CMD_LTLINK)$(LIBTOOL) --tag=CC --mode=link $(CC) -o $@ $(OBJECTS) $(GEN_OBJECTS) $(VERSION_OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
+	$(RUN_CMD_LTLINK)$(LIBTOOL) --tag=CXX --mode=link $(CXX) -o $@ $(OBJECTS) $(GEN_OBJECTS) $(VERSION_OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
 
 $(objects)/$(SDLMAIN_TARGET): $(SDLMAIN_OBJECTS)
-	$(RUN_CMD_LTLINK)$(LIBTOOL) --tag=CC --mode=link $(CC) -static -o $@ $(SDLMAIN_OBJECTS) -rpath $(libdir)
+	$(RUN_CMD_LTLINK)$(LIBTOOL) --tag=CXX --mode=link $(CXX) -static -o $@ $(SDLMAIN_OBJECTS) -rpath $(libdir)
 
 $(objects)/$(SDLTEST_TARGET): $(SDLTEST_OBJECTS)
-	$(RUN_CMD_LTLINK)$(LIBTOOL) --tag=CC --mode=link $(CC) -static -o $@ $(SDLTEST_OBJECTS) -rpath $(libdir)
+	$(RUN_CMD_LTLINK)$(LIBTOOL) --tag=CXX --mode=link $(CXX) -static -o $@ $(SDLTEST_OBJECTS) -rpath $(libdir)
 
 install: all install-bin install-hdrs install-lib install-data
 install-bin:
diff --git a/configure.ac b/configure.ac
index 166d06b..8d8da32 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3692,9 +3692,6 @@ AS_HELP_STRING([--enable-render-d3d], [enable the Direct3D render driver [[defau
         # The Haiku platform requires special setup.
         SOURCES="$srcdir/src/main/haiku/*.cc $SOURCES"
         EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lroot -lbe -lmedia -lgame -ldevice -ltextencoding"
-        # Haiku's x86 spins use libstdc++.r4.so (for binary compat?), but
-        #  other spins, like x86-64, use a more standard "libstdc++.so.*"
-        AC_CHECK_FILE("/boot/system/lib/libstdc++.r4.so", EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lstdc++.r4", EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lstdc++")
         ;;
     arm*-apple-darwin*|*-ios-*)
         ARCH=ios
-- 
2.24.1

From abcdfa5001ea85210c0b76652f7cb4791e7fdd2c Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Fri, 2 Feb 2018 10:40:00 +0100
Subject: Fix crash when opening window

- _num_clips was not set in constructor, so a NULL _clips could be
  mistakenly dereferenced.
- As _clips is accessible outside the class, it is not a good idea to
  free/reallocate it. Try to limit this by reallocating only when it needs to
  grow.
---
 src/video/haiku/SDL_BWin.h | 15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)

diff --git a/src/video/haiku/SDL_BWin.h b/src/video/haiku/SDL_BWin.h
index da84dd5..1534059 100644
--- a/src/video/haiku/SDL_BWin.h
+++ b/src/video/haiku/SDL_BWin.h
@@ -86,6 +86,7 @@ class SDL_BWin:public BDirectWindow
         _buffer_locker = new BLocker();
         _bitmap = NULL;
         _clips = NULL;
+        _num_clips = 0;
 
 #ifdef DRAWTHREAD
         _draw_thread_id = spawn_thread(HAIKU_DrawThread, "drawing_thread",
@@ -179,13 +180,17 @@ class SDL_BWin:public BDirectWindow
             _connected = true;
 
         case B_DIRECT_MODIFY:
-            if(_clips) {
-                free(_clips);
-                _clips = NULL;
+            if (info->clip_list_count > _num_clips)
+            {
+                if(_clips) {
+                    free(_clips);
+                    _clips = NULL;
+                }
             }
 
             _num_clips = info->clip_list_count;
-            _clips = (clipping_rect *)malloc(_num_clips*sizeof(clipping_rect));
+            if (_clips == NULL)
+                _clips = (clipping_rect *)malloc(_num_clips*sizeof(clipping_rect));
             if(_clips) {
                 memcpy(_clips, info->clip_list,
                     _num_clips*sizeof(clipping_rect));
@@ -652,7 +657,7 @@ private:
     clipping_rect   _bounds;
     BLocker        *_buffer_locker;
     clipping_rect  *_clips;
-    int32           _num_clips;
+    uint32          _num_clips;
     int32           _bytes_per_px;
     thread_id       _draw_thread_id;
 
-- 
2.24.1

From c2025ba519d97a36bb1bd45735dbaafd9f275a08 Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Sat, 15 Sep 2018 23:16:25 +1000
Subject: Add simple relative mode for mouse

---
 src/main/haiku/SDL_BApp.h | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index ae51ebc..764c8fc 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -230,6 +230,21 @@ private:
         win = GetSDLWindow(winID);
         SDL_SendMouseMotion(win, 0, 0, x, y);
 
+		// Simple relative mode support for mouse.
+		if ((SDL_GetMouse()->relative_mode ||
+			(win->flags & SDL_WINDOW_INPUT_GRABBED)) &&
+			(win->flags & SDL_WINDOW_INPUT_FOCUS)) {
+			int winWidth, winHeight, winPosX, winPosY;
+			SDL_GetWindowSize(win, &winWidth, &winHeight);
+			SDL_GetWindowPosition(win, &winPosX, &winPosY);
+			set_mouse_position((winPosX + winWidth / 2), (winPosY + winHeight / 2));
+			if (!be_app->IsCursorHidden())
+				be_app->HideCursor();
+		} else {
+			if (be_app->IsCursorHidden())
+				be_app->ShowCursor();
+		}
+
         /* Tell the application that the mouse passed over, redraw needed */
         HAIKU_UpdateWindowFramebuffer(NULL,win,NULL,-1);
     }
-- 
2.24.1

From f9f064023ab90c9c159880b7121c98f7229554bf Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Tue, 18 Sep 2018 20:47:07 +1000
Subject: Add support for relative mouse mode

---
 src/main/haiku/SDL_BApp.h  |  5 ++++-
 src/video/haiku/SDL_BWin.h | 30 ++++++++----------------------
 2 files changed, 12 insertions(+), 23 deletions(-)

diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index 764c8fc..3e7b472 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -228,7 +228,6 @@ private:
             return;
         }
         win = GetSDLWindow(winID);
-        SDL_SendMouseMotion(win, 0, 0, x, y);
 
 		// Simple relative mode support for mouse.
 		if ((SDL_GetMouse()->relative_mode ||
@@ -237,10 +236,14 @@ private:
 			int winWidth, winHeight, winPosX, winPosY;
 			SDL_GetWindowSize(win, &winWidth, &winHeight);
 			SDL_GetWindowPosition(win, &winPosX, &winPosY);
+			int dx = x - (winWidth / 2);
+			int dy = y - (winHeight / 2);
+			SDL_SendMouseMotion(win, 0, SDL_GetMouse()->relative_mode, dx, dy);
 			set_mouse_position((winPosX + winWidth / 2), (winPosY + winHeight / 2));
 			if (!be_app->IsCursorHidden())
 				be_app->HideCursor();
 		} else {
+			SDL_SendMouseMotion(win, 0, 0, x, y);
 			if (be_app->IsCursorHidden())
 				be_app->ShowCursor();
 		}
diff --git a/src/video/haiku/SDL_BWin.h b/src/video/haiku/SDL_BWin.h
index 1534059..9f79927 100644
--- a/src/video/haiku/SDL_BWin.h
+++ b/src/video/haiku/SDL_BWin.h
@@ -319,22 +319,17 @@ class SDL_BWin:public BDirectWindow
                 && msg->FindInt32("be:transit", &transit) == B_OK) {
                 _MouseMotionEvent(where, transit);
             }
+            break;
 
-            /* FIXME: Apparently a button press/release event might be dropped
-               if made before before a different button is released.  Does
-               B_MOUSE_MOVED have the data needed to check if a mouse button
-               state has changed? */
+        case B_MOUSE_DOWN:
             if (msg->FindInt32("buttons", &buttons) == B_OK) {
-                _MouseButtonEvent(buttons);
+                _MouseButtonEvent(buttons, SDL_PRESSED);
             }
             break;
 
-        case B_MOUSE_DOWN:
         case B_MOUSE_UP:
-            /* _MouseButtonEvent() detects any and all buttons that may have
-               changed state, as well as that button's new state */
             if (msg->FindInt32("buttons", &buttons) == B_OK) {
-                _MouseButtonEvent(buttons);
+                _MouseButtonEvent(buttons, SDL_RELEASED);
             }
             break;
 
@@ -497,26 +492,17 @@ private:
  if true:  SDL_SetCursor(NULL); */
     }
 
-    void _MouseButtonEvent(int32 buttons) {
+    void _MouseButtonEvent(int32 buttons, Uint8 state) {
         int32 buttonStateChange = buttons ^ _last_buttons;
 
-        /* Make sure at least one button has changed state */
-        if( !(buttonStateChange) ) {
-            return;
-        }
-
-        /* Add any mouse button events */
         if(buttonStateChange & B_PRIMARY_MOUSE_BUTTON) {
-            _SendMouseButton(SDL_BUTTON_LEFT, buttons &
-                B_PRIMARY_MOUSE_BUTTON);
+            _SendMouseButton(SDL_BUTTON_LEFT, state);
         }
         if(buttonStateChange & B_SECONDARY_MOUSE_BUTTON) {
-            _SendMouseButton(SDL_BUTTON_RIGHT, buttons &
-                B_PRIMARY_MOUSE_BUTTON);
+            _SendMouseButton(SDL_BUTTON_RIGHT, state);
         }
         if(buttonStateChange & B_TERTIARY_MOUSE_BUTTON) {
-            _SendMouseButton(SDL_BUTTON_MIDDLE, buttons &
-                B_PRIMARY_MOUSE_BUTTON);
+            _SendMouseButton(SDL_BUTTON_MIDDLE, state);
         }
 
         _last_buttons = buttons;
-- 
2.24.1

From f4a35e5e8ca0df1311d0d9259e7be3d16d18d697 Mon Sep 17 00:00:00 2001
From: Peter Kosyh <p.kosyh@gmail.com>
Date: Sat, 6 Oct 2018 12:48:15 +0300
Subject: haiku: mouse->ShowMouse method added

---
 src/main/haiku/SDL_BApp.h     |  2 +-
 src/video/haiku/SDL_bvideo.cc | 30 ++++++++++++++++++++++++++++++
 2 files changed, 31 insertions(+), 1 deletion(-)

diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index 3e7b472..01fcba7 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -244,7 +244,7 @@ private:
 				be_app->HideCursor();
 		} else {
 			SDL_SendMouseMotion(win, 0, 0, x, y);
-			if (be_app->IsCursorHidden())
+			if (SDL_ShowCursor(-1) && be_app->IsCursorHidden())
 				be_app->ShowCursor();
 		}
 
diff --git a/src/video/haiku/SDL_bvideo.cc b/src/video/haiku/SDL_bvideo.cc
index 52e0f1d..68300a9 100644
--- a/src/video/haiku/SDL_bvideo.cc
+++ b/src/video/haiku/SDL_bvideo.cc
@@ -19,6 +19,7 @@
   3. This notice may not be removed or altered from any source distribution.
 */
 #include "../../SDL_internal.h"
+#include "../../main/haiku/SDL_BApp.h"
 
 #if SDL_VIDEO_DRIVER_HAIKU
 
@@ -132,6 +133,33 @@ void HAIKU_DeleteDevice(SDL_VideoDevice * device)
     SDL_free(device);
 }
 
+static int HAIKU_ShowCursor(SDL_Cursor *cur)
+{
+	SDL_Mouse *mouse = SDL_GetMouse();
+	int show;
+	if (!mouse)
+		return 0;
+	show = (cur || !mouse->focus);
+	if (show) {
+		if (be_app->IsCursorHidden())
+			be_app->ShowCursor();
+	} else {
+		if (!be_app->IsCursorHidden())
+			be_app->HideCursor();
+	}
+	return 0;
+}
+
+static void HAIKU_MouseInit(_THIS)
+{
+	SDL_Mouse *mouse = SDL_GetMouse();
+	if (!mouse)
+		return;
+	mouse->ShowCursor = HAIKU_ShowCursor;
+	mouse->cur_cursor = (SDL_Cursor*)0x1;
+	mouse->def_cursor = (SDL_Cursor*)0x2;
+}
+
 int HAIKU_VideoInit(_THIS)
 {
     /* Initialize the Be Application for appserver interaction */
@@ -145,6 +173,8 @@ int HAIKU_VideoInit(_THIS)
     /* Init the keymap */
     HAIKU_InitOSKeymap();
 
+    HAIKU_MouseInit(_this);
+
 #if SDL_VIDEO_OPENGL
         /* testgl application doesn't load library, just tries to load symbols */
         /* is it correct? if so we have to load library here */
-- 
2.24.1

From 3ca20b09b04bdb1778aa4f2462a3e8f48ac1dc3a Mon Sep 17 00:00:00 2001
From: Peter Kosyh <p.kosyh@gmail.com>
Date: Sat, 6 Oct 2018 13:50:30 +0300
Subject: mouse_relative fix

---
 src/main/haiku/SDL_BApp.h | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index 01fcba7..a4367f6 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -230,9 +230,7 @@ private:
         win = GetSDLWindow(winID);
 
 		// Simple relative mode support for mouse.
-		if ((SDL_GetMouse()->relative_mode ||
-			(win->flags & SDL_WINDOW_INPUT_GRABBED)) &&
-			(win->flags & SDL_WINDOW_INPUT_FOCUS)) {
+		if (SDL_GetMouse()->relative_mode) {
 			int winWidth, winHeight, winPosX, winPosY;
 			SDL_GetWindowSize(win, &winWidth, &winHeight);
 			SDL_GetWindowPosition(win, &winPosX, &winPosY);
-- 
2.24.1

From 6a7ccc5cb603c3508a54a550f9433560f7cf15c7 Mon Sep 17 00:00:00 2001
From: Peter Kosyh <p.kosyh@gmail.com>
Date: Sat, 6 Oct 2018 14:28:41 +0300
Subject: mouse wheel y invert

---
 src/main/haiku/SDL_BApp.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index a4367f6..6bdf6db 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -277,7 +277,7 @@ private:
             return;
         }
         win = GetSDLWindow(winID);
-        SDL_SendMouseWheel(win, 0, xTicks, yTicks, SDL_MOUSEWHEEL_NORMAL);
+        SDL_SendMouseWheel(win, 0, xTicks, -yTicks, SDL_MOUSEWHEEL_NORMAL);
     }
 
     void _HandleKey(BMessage *msg) {
-- 
2.24.1

From b72e75869298a94a610813eae30dcadb10283ba8 Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Mon, 5 Nov 2018 23:25:54 +1000
Subject: Disable pointer history

---
 src/video/haiku/SDL_BWin.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/video/haiku/SDL_BWin.h b/src/video/haiku/SDL_BWin.h
index 9f79927..be2fafd 100644
--- a/src/video/haiku/SDL_BWin.h
+++ b/src/video/haiku/SDL_BWin.h
@@ -140,6 +140,7 @@ class SDL_BWin:public BDirectWindow
             _gl_type = gl_flags;
         }
         AddChild(_SDL_GLView);
+        _SDL_GLView->SetEventMask(B_POINTER_EVENTS | B_KEYBOARD_EVENTS, B_NO_POINTER_HISTORY);
         _SDL_GLView->EnableDirectMode(true);
         _SDL_GLView->LockGL();  /* "New" GLViews are created */
         Unlock();
-- 
2.24.1

From 94fc47765028b5ee7b18806dbc5185bcad363a77 Mon Sep 17 00:00:00 2001
From: EXL <exlmotodev@gmail.com>
Date: Wed, 5 Dec 2018 07:02:11 +0000
Subject: Implement message box for Haiku

Add implementation for functions:

SDL_ShowSimpleMessageBox()
SDL_ShowMessageBox()

Add simple customization support also.
Fix build for x86_gcc2.
---
 include/SDL_syswm.h                |   3 +-
 src/main/haiku/SDL_BeApp.cc        |   5 +-
 src/main/haiku/SDL_BeApp.h         |   3 +
 src/video/SDL_video.c              |  12 +-
 src/video/haiku/SDL_bmessagebox.cc | 425 +++++++++++++++++++++++++++++
 src/video/haiku/SDL_bmessagebox.h  |  45 +++
 src/video/haiku/SDL_bwindow.cc     |  12 +-
 7 files changed, 500 insertions(+), 5 deletions(-)
 create mode 100644 src/video/haiku/SDL_bmessagebox.cc
 create mode 100644 src/video/haiku/SDL_bmessagebox.h

diff --git a/include/SDL_syswm.h b/include/SDL_syswm.h
index 7aa8c68..162fd5d 100644
--- a/include/SDL_syswm.h
+++ b/include/SDL_syswm.h
@@ -129,7 +129,8 @@ typedef enum
     SDL_SYSWM_WINRT,
     SDL_SYSWM_ANDROID,
     SDL_SYSWM_VIVANTE,
-    SDL_SYSWM_OS2
+    SDL_SYSWM_OS2,
+    SDL_SYSWM_HAIKU
 } SDL_SYSWM_TYPE;
 
 /**
diff --git a/src/main/haiku/SDL_BeApp.cc b/src/main/haiku/SDL_BeApp.cc
index 2d78059..4eb215c 100644
--- a/src/main/haiku/SDL_BeApp.cc
+++ b/src/main/haiku/SDL_BeApp.cc
@@ -48,13 +48,14 @@ extern "C" {
 static int SDL_BeAppActive = 0;
 static SDL_Thread *SDL_AppThread = NULL;
 
+/* Default application signature */
+const char *signature = "application/x-SDL-executable";
+
 static int
 StartBeApp(void *unused)
 {
     BApplication *App;
 
-    // default application signature
-    const char *signature = "application/x-SDL-executable";
     // dig resources for correct signature
     image_info info;
     int32 cookie = 0;
diff --git a/src/main/haiku/SDL_BeApp.h b/src/main/haiku/SDL_BeApp.h
index d14e14f..5fcfa54 100644
--- a/src/main/haiku/SDL_BeApp.h
+++ b/src/main/haiku/SDL_BeApp.h
@@ -31,6 +31,9 @@ extern int SDL_InitBeApp(void);
 /* Quit the Be Application, if there's nothing left to do */
 extern void SDL_QuitBeApp(void);
 
+/* Be Application Signature*/
+extern const char *signature;
+
 /* vi: set ts=4 sw=4 expandtab: */
 
 #ifdef __cplusplus
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index c63f746..655175b 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -3843,9 +3843,12 @@ SDL_IsScreenKeyboardShown(SDL_Window *window)
 #if SDL_VIDEO_DRIVER_X11
 #include "x11/SDL_x11messagebox.h"
 #endif
+#if SDL_VIDEO_DRIVER_HAIKU
+#include "haiku/SDL_bmessagebox.h"
+#endif
 
 
-#if SDL_VIDEO_DRIVER_WINDOWS || SDL_VIDEO_DRIVER_WINRT || SDL_VIDEO_DRIVER_COCOA || SDL_VIDEO_DRIVER_UIKIT || SDL_VIDEO_DRIVER_X11
+#if SDL_VIDEO_DRIVER_WINDOWS || SDL_VIDEO_DRIVER_WINRT || SDL_VIDEO_DRIVER_COCOA || SDL_VIDEO_DRIVER_UIKIT || SDL_VIDEO_DRIVER_X11 || SDL_VIDEO_DRIVER_HAIKU
 static SDL_bool SDL_MessageboxValidForDriver(const SDL_MessageBoxData *messageboxdata, SDL_SYSWM_TYPE drivertype)
 {
     SDL_SysWMinfo info;
@@ -3937,6 +3940,13 @@ SDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
         X11_ShowMessageBox(messageboxdata, buttonid) == 0) {
         retval = 0;
     }
+#endif
+#if SDL_VIDEO_DRIVER_HAIKU
+    if (retval == -1 &&
+        SDL_MessageboxValidForDriver(messageboxdata, SDL_SYSWM_HAIKU) &&
+        BE_ShowMessageBox(messageboxdata, buttonid) == 0) {
+        retval = 0;
+    }
 #endif
     if (retval == -1) {
         SDL_SetError("No message system available");
diff --git a/src/video/haiku/SDL_bmessagebox.cc b/src/video/haiku/SDL_bmessagebox.cc
new file mode 100644
index 0000000..9b9fe14
--- /dev/null
+++ b/src/video/haiku/SDL_bmessagebox.cc
@@ -0,0 +1,425 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+  Copyright (C) 2018 EXL <exlmotodev@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_HAIKU
+
+#include "SDL_messagebox.h"
+
+/* For application signature. */
+#include "../../main/haiku/SDL_BeApp.h"
+
+#include <Alert.h>
+#include <Application.h>
+#include <Button.h>
+#include <Font.h>
+#include <Layout.h>
+#include <String.h>
+#include <TextView.h>
+#include <View.h>
+#include <Window.h>
+
+#include <InterfaceDefs.h>
+#include <SupportDefs.h>
+#include <GraphicsDefs.h>
+
+#include <new>
+#include <vector>
+#include <algorithm>
+
+enum
+{
+	G_CLOSE_BUTTON_ID   = -1,
+	G_DEFAULT_BUTTON_ID = 0,
+	G_MAX_STRING_LENGTH_BYTES = 120
+};
+
+class BE_SDL_MessageBox : public BAlert
+{
+	float fComputedMessageBoxWidth;
+
+	BTextView *fMessageBoxTextView;
+
+	int fCloseButton;
+	int fDefaultButton;
+
+	bool fCustomColorScheme;
+	bool fThereIsLongLine;
+	rgb_color fTextColor;
+
+	const char *fTitle;
+	const char *BE_SDL_DefTitle;
+	const char *BE_SDL_DefMessage;
+	const char *BE_SDL_DefButton;
+
+	std::vector<const SDL_MessageBoxButtonData *> fButtons;
+
+	static bool
+	SortButtonsPredicate(const SDL_MessageBoxButtonData *aButtonLeft,
+	                                 const SDL_MessageBoxButtonData *aButtonRight)
+	{
+		return aButtonLeft->buttonid < aButtonRight->buttonid;
+	}
+
+	alert_type
+	ConvertMessageBoxType(const SDL_MessageBoxFlags aWindowType) const
+	{
+		switch (aWindowType)
+		{
+			default:
+			case SDL_MESSAGEBOX_WARNING:
+			{
+				return B_WARNING_ALERT;
+			}
+			case SDL_MESSAGEBOX_ERROR:
+			{
+				return B_STOP_ALERT;
+			}
+			case SDL_MESSAGEBOX_INFORMATION:
+			{
+				return B_INFO_ALERT;
+			}
+		}
+	}
+
+	rgb_color
+	ConvertColorType(const SDL_MessageBoxColor *aColor) const
+	{
+		rgb_color color = { aColor->r, aColor->g, aColor->b, color.alpha = 255 };
+		return color;
+	}
+
+	int32
+	GetLeftPanelWidth(void) const
+	{
+		// See file "haiku/src/kits/interface/Alert.cpp" for this magic numbers.
+		//    IconStripeWidth = 30 * Scale
+		//    IconSize = 32 * Scale
+		//    Scale = max_c(1, ((int32)be_plain_font->Size() + 15) / 16)
+		//    RealWidth = (IconStripeWidth * Scale) + (IconSize * Scale)
+
+		int32 scale = max_c(1, ((int32)be_plain_font->Size() + 15) / 16);
+		return (30 * scale) + (32 * scale);
+	}
+
+	void
+	UpdateTextViewWidth(void)
+	{
+		fComputedMessageBoxWidth = fMessageBoxTextView->PreferredSize().Width() + GetLeftPanelWidth();
+	}
+
+	void
+	ParseSdlMessageBoxData(const SDL_MessageBoxData *aMessageBoxData)
+	{
+		if (aMessageBoxData == NULL)
+		{
+			SetTitle(BE_SDL_DefTitle);
+			SetMessageText(BE_SDL_DefMessage);
+			AddButton(BE_SDL_DefButton);
+			return;
+		}
+
+		if (aMessageBoxData->numbuttons <= 0)
+		{
+			AddButton(BE_SDL_DefButton);
+		}
+		else
+		{
+			AddSdlButtons(aMessageBoxData->buttons, aMessageBoxData->numbuttons);
+		}
+
+		if (aMessageBoxData->colorScheme != NULL)
+		{
+			fCustomColorScheme = true;
+			ApplyAndParseColorScheme(aMessageBoxData->colorScheme);
+		}
+
+		(aMessageBoxData->title != NULL) ?
+			SetTitle(aMessageBoxData->title) : SetTitle(BE_SDL_DefTitle);
+		(aMessageBoxData->message != NULL) ?
+			SetMessageText(aMessageBoxData->message) : SetMessageText(BE_SDL_DefMessage);
+
+		SetType(ConvertMessageBoxType(static_cast<SDL_MessageBoxFlags>(aMessageBoxData->flags)));
+	}
+
+	void
+	ApplyAndParseColorScheme(const SDL_MessageBoxColorScheme *aColorScheme)
+	{
+		SetBackgroundColor(&aColorScheme->colors[SDL_MESSAGEBOX_COLOR_BACKGROUND]);
+		fTextColor = ConvertColorType(&aColorScheme->colors[SDL_MESSAGEBOX_COLOR_TEXT]);
+		SetButtonColors(&aColorScheme->colors[SDL_MESSAGEBOX_COLOR_BUTTON_BORDER],
+		                &aColorScheme->colors[SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND],
+		                &aColorScheme->colors[SDL_MESSAGEBOX_COLOR_TEXT],
+		                &aColorScheme->colors[SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED]);
+	}
+
+	void
+	SetButtonColors(const SDL_MessageBoxColor *aBorderColor,
+	                const SDL_MessageBoxColor *aBackgroundColor,
+	                const SDL_MessageBoxColor *aTextColor,
+	                const SDL_MessageBoxColor *aSelectedColor)
+	{
+		if (fCustomColorScheme)
+		{
+			int32 countButtons = CountButtons();
+			for (int i = 0; i < countButtons; ++i)
+			{
+				ButtonAt(i)->SetViewColor(ConvertColorType(aBorderColor));
+				ButtonAt(i)->SetLowColor(ConvertColorType(aBackgroundColor));
+
+				// This doesn't work. See this why:
+				// https://github.com/haiku/haiku/commit/de9c53f8f5008c7b3b0af75d944a628e17f6dffe
+				// Let it remain.
+				ButtonAt(i)->SetHighColor(ConvertColorType(aTextColor));
+			}
+		}
+		// TODO: Not Implemented.
+		// Is it even necessary?!
+		(void)aSelectedColor;
+	}
+
+	void
+	SetBackgroundColor(const SDL_MessageBoxColor *aColor)
+	{
+		rgb_color background = ConvertColorType(aColor);
+
+		GetLayout()->View()->SetViewColor(background);
+		// See file "haiku/src/kits/interface/Alert.cpp", the "TAlertView" is the internal name of the left panel.
+		FindView("TAlertView")->SetViewColor(background);
+		fMessageBoxTextView->SetViewColor(background);
+	}
+
+	bool
+	CheckLongLines(const char *aMessage)
+	{
+		int final = 0;
+
+		// This UTF-8 friendly.
+		BString message = aMessage;
+		int32 length = message.CountChars();
+
+		for (int i = 0, c = 0; i < length; ++i)
+		{
+			c++;
+			if (*(message.CharAt(i)) == '\n')
+			{
+				c = 0;
+			}
+			if (c > final)
+			{
+				final = c;
+			}
+		}
+
+		return (final > G_MAX_STRING_LENGTH_BYTES);
+	}
+
+	void
+	SetMessageText(const char *aMessage)
+	{
+		fThereIsLongLine = CheckLongLines(aMessage);
+		if (fThereIsLongLine)
+		{
+			fMessageBoxTextView->SetWordWrap(true);
+		}
+
+		rgb_color textColor = ui_color(B_PANEL_TEXT_COLOR);
+		if (fCustomColorScheme)
+		{
+			textColor = fTextColor;
+		}
+
+		/*
+		if (fNoTitledWindow)
+		{
+			fMessageBoxTextView->SetFontAndColor(be_bold_font);
+			fMessageBoxTextView->Insert(fTitle);
+			fMessageBoxTextView->Insert("\n\n");
+			fMessageBoxTextView->SetFontAndColor(be_plain_font);
+		}
+		*/
+
+		fMessageBoxTextView->SetFontAndColor(be_plain_font, B_FONT_ALL, &textColor);
+		fMessageBoxTextView->Insert(aMessage);
+
+		// Be sure to call update width method.
+		UpdateTextViewWidth();
+	}
+
+	void
+	AddSdlButtons(const SDL_MessageBoxButtonData *aButtons, int aNumButtons)
+	{
+		for (int i = 0; i < aNumButtons; ++i)
+		{
+			fButtons.push_back(&aButtons[i]);
+		}
+
+		std::sort(fButtons.begin(), fButtons.end(), &BE_SDL_MessageBox::SortButtonsPredicate);
+
+		size_t countButtons = fButtons.size();
+		for (size_t i = 0; i < countButtons; ++i)
+		{
+			switch (fButtons[i]->flags)
+			{
+				case SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT:
+				{
+					fCloseButton = static_cast<int>(i);
+					break;
+				}
+				case SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT:
+				{
+					fDefaultButton = static_cast<int>(i);
+					break;
+				}
+				default:
+				{
+					break;
+				}
+			}
+			AddButton(fButtons[i]->text);
+		}
+
+		SetDefaultButton(ButtonAt(fDefaultButton));
+	}
+
+public:
+	explicit
+	BE_SDL_MessageBox(const SDL_MessageBoxData *aMessageBoxData)
+		: BAlert(NULL, NULL, NULL, NULL, NULL, B_WIDTH_FROM_LABEL, B_WARNING_ALERT),
+		  fComputedMessageBoxWidth(0.0f),
+		  fCloseButton(G_CLOSE_BUTTON_ID), fDefaultButton(G_DEFAULT_BUTTON_ID),
+		  fCustomColorScheme(false), fThereIsLongLine(false),
+		  BE_SDL_DefTitle("SDL2 MessageBox"),
+		  BE_SDL_DefMessage("Some information has been lost."),
+		  BE_SDL_DefButton("OK")
+	{
+		// MessageBox settings.
+		// We need a title to display it.
+		SetLook(B_TITLED_WINDOW_LOOK);
+		SetFlags(Flags() | B_CLOSE_ON_ESCAPE);
+
+		// MessageBox TextView settings.
+		fMessageBoxTextView = TextView();
+		fMessageBoxTextView->SetWordWrap(false);
+		fMessageBoxTextView->SetStylable(true);
+
+		ParseSdlMessageBoxData(aMessageBoxData);
+	}
+
+	int
+	GetCloseButtonId(void) const
+	{
+		return fCloseButton;
+	}
+
+	virtual
+	~BE_SDL_MessageBox(void)
+	{
+		fButtons.clear();
+	}
+
+protected:
+	virtual void
+	FrameResized(float aNewWidth, float aNewHeight)
+	{
+		if (fComputedMessageBoxWidth > aNewWidth)
+		{
+			ResizeTo(fComputedMessageBoxWidth, aNewHeight);
+		}
+		else
+		{
+			BAlert::FrameResized(aNewWidth, aNewHeight);
+		}
+	}
+
+	virtual void
+	SetTitle(const char* aTitle)
+	{
+		fTitle = aTitle;
+		BAlert::SetTitle(aTitle);
+	}
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int
+BE_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
+{
+	// Initialize button by closed or error value first.
+	*buttonid = G_CLOSE_BUTTON_ID;
+
+	// We need to check "be_app" pointer to "NULL". The "messageboxdata->window" pointer isn't appropriate here
+	// because it is possible to create a MessageBox from another thread. This fixes the following errors:
+	// "You need a valid BApplication object before interacting with the app_server."
+	// "2 BApplication objects were created. Only one is allowed."
+	BApplication *application = NULL;
+	if (be_app == NULL)
+	{
+		application = new(std::nothrow) BApplication(signature);
+		if (application == NULL)
+		{
+			return SDL_SetError("Cannot create the BApplication object. Lack of memory?");
+		}
+	}
+
+	BE_SDL_MessageBox *SDL_MessageBox = new(std::nothrow) BE_SDL_MessageBox(messageboxdata);
+	if (SDL_MessageBox == NULL)
+	{
+		return SDL_SetError("Cannot create the BE_SDL_MessageBox (BAlert inheritor) object. Lack of memory?");
+	}
+	const int closeButton = SDL_MessageBox->GetCloseButtonId();
+	int pushedButton = SDL_MessageBox->Go();
+
+	// The close button is equivalent to pressing Escape.
+	if (closeButton != G_CLOSE_BUTTON_ID && pushedButton == G_CLOSE_BUTTON_ID)
+	{
+		pushedButton = closeButton;
+	}
+
+	// It's deleted by itself after the "Go()" method was executed.
+	/*
+	if (messageBox != NULL)
+	{
+		delete messageBox;
+	}
+	*/
+	if (application != NULL)
+	{
+		delete application;
+	}
+
+	// Initialize button by real pushed value then.
+	*buttonid = pushedButton;
+
+	return 0;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SDL_VIDEO_DRIVER_HAIKU */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/haiku/SDL_bmessagebox.h b/src/video/haiku/SDL_bmessagebox.h
new file mode 100644
index 0000000..4f35cda
--- /dev/null
+++ b/src/video/haiku/SDL_bmessagebox.h
@@ -0,0 +1,45 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+  Copyright (C) 2018 EXL <exlmotodev@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_BMESSAGEBOX_H
+#define SDL_BMESSAGEBOX_H
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_HAIKU
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int
+BE_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SDL_VIDEO_DRIVER_HAIKU */
+
+#endif
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/haiku/SDL_bwindow.cc b/src/video/haiku/SDL_bwindow.cc
index 6c68802..e818532 100644
--- a/src/video/haiku/SDL_bwindow.cc
+++ b/src/video/haiku/SDL_bwindow.cc
@@ -26,6 +26,8 @@
 #include "SDL_BWin.h"
 #include <new>
 
+#include "SDL_syswm.h"
+
 /* Define a path to window's BWIN data */
 #ifdef __cplusplus
 extern "C" {
@@ -217,7 +219,15 @@ void HAIKU_DestroyWindow(_THIS, SDL_Window * window) {
 SDL_bool HAIKU_GetWindowWMInfo(_THIS, SDL_Window * window,
                                     struct SDL_SysWMinfo *info) {
     /* FIXME: What is the point of this? What information should be included? */
-    return SDL_FALSE;
+	if (info->version.major == SDL_MAJOR_VERSION &&
+	    info->version.minor == SDL_MINOR_VERSION) {
+	    info->subsystem = SDL_SYSWM_HAIKU;
+	    return SDL_TRUE;
+	} else {
+	    SDL_SetError("Application not compiled with SDL %d.%d",
+	                 SDL_MAJOR_VERSION, SDL_MINOR_VERSION);
+	    return SDL_FALSE;
+	}
 }
 
 
-- 
2.24.1

From afd3843987cc6befbc5ac99317f768e5405215dd Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Thu, 20 Jun 2019 23:29:44 +1000
Subject: Move SetEventMask to SetRelativeMouseMode handler

---
 src/video/haiku/SDL_BWin.h    |  1 -
 src/video/haiku/SDL_bvideo.cc | 27 +++++++++++++++++++++++++++
 2 files changed, 27 insertions(+), 1 deletion(-)

diff --git a/src/video/haiku/SDL_BWin.h b/src/video/haiku/SDL_BWin.h
index be2fafd..9f79927 100644
--- a/src/video/haiku/SDL_BWin.h
+++ b/src/video/haiku/SDL_BWin.h
@@ -140,7 +140,6 @@ class SDL_BWin:public BDirectWindow
             _gl_type = gl_flags;
         }
         AddChild(_SDL_GLView);
-        _SDL_GLView->SetEventMask(B_POINTER_EVENTS | B_KEYBOARD_EVENTS, B_NO_POINTER_HISTORY);
         _SDL_GLView->EnableDirectMode(true);
         _SDL_GLView->LockGL();  /* "New" GLViews are created */
         Unlock();
diff --git a/src/video/haiku/SDL_bvideo.cc b/src/video/haiku/SDL_bvideo.cc
index 68300a9..5e564c9 100644
--- a/src/video/haiku/SDL_bvideo.cc
+++ b/src/video/haiku/SDL_bvideo.cc
@@ -36,6 +36,11 @@ extern "C" {
 #include "SDL_bmodes.h"
 #include "SDL_bframebuffer.h"
 #include "SDL_bevents.h"
+#include "SDL_BWin.h"
+
+static SDL_INLINE SDL_BWin *_ToBeWin(SDL_Window *window) {
+    return ((SDL_BWin*)(window->driverdata));
+}
 
 /* FIXME: Undefined functions */
 //    #define HAIKU_PumpEvents NULL
@@ -150,12 +155,34 @@ static int HAIKU_ShowCursor(SDL_Cursor *cur)
 	return 0;
 }
 
+static int
+HAIKU_SetRelativeMouseMode(SDL_bool enabled)
+{
+    SDL_Window *window = SDL_GetMouseFocus();
+    if (!window) {
+      return 0;
+    }
+
+	SDL_BWin *bewin = _ToBeWin(window);
+	BGLView *_SDL_GLView = bewin->GetGLView();
+
+	bewin->Lock();
+	if (enabled)
+		_SDL_GLView->SetEventMask(B_POINTER_EVENTS | B_KEYBOARD_EVENTS, B_NO_POINTER_HISTORY);
+	else
+		_SDL_GLView->SetEventMask(0, 0);
+	bewin->Unlock();
+
+    return 0;
+}
+
 static void HAIKU_MouseInit(_THIS)
 {
 	SDL_Mouse *mouse = SDL_GetMouse();
 	if (!mouse)
 		return;
 	mouse->ShowCursor = HAIKU_ShowCursor;
+	mouse->SetRelativeMouseMode = HAIKU_SetRelativeMouseMode;
 	mouse->cur_cursor = (SDL_Cursor*)0x1;
 	mouse->def_cursor = (SDL_Cursor*)0x2;
 }
-- 
2.24.1

From 87dac464e55f2b0c0f3ee7d17aab56b49743c813 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Tue, 29 Oct 2019 19:13:09 +0100
Subject: remove unused stuff

---
 configure.ac | 85 ----------------------------------------------------
 1 file changed, 85 deletions(-)

diff --git a/configure.ac b/configure.ac
index 8d8da32..d8950c2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -887,45 +887,6 @@ AS_HELP_STRING([--enable-oss], [support the OSS audio API [[default=maybe]]]),
     fi
 }
 
-dnl See if the ALSA audio interface is supported
-CheckALSA()
-{
-    AC_ARG_ENABLE(alsa,
-AS_HELP_STRING([--enable-alsa], [support the ALSA audio API [[default=yes]]]),
-                  , enable_alsa=yes)
-    if test x$enable_audio = xyes -a x$enable_alsa = xyes; then
-        AM_PATH_ALSA(1.0.11, have_alsa=yes, have_alsa=no)
-        # Restore all flags from before the ALSA detection runs
-        CFLAGS="$alsa_save_CFLAGS"
-        LDFLAGS="$alsa_save_LDFLAGS"
-        LIBS="$alsa_save_LIBS"
-        if test x$have_alsa = xyes; then
-            AC_ARG_ENABLE(alsa-shared,
-AS_HELP_STRING([--enable-alsa-shared], [dynamically load ALSA audio support [[default=yes]]]),
-                          , enable_alsa_shared=yes)
-            alsa_lib=[`find_lib "libasound.so.*" "$ALSA_LIBS" | sed 's/.*\/\(.*\)/\1/; q'`]
-
-            AC_DEFINE(SDL_AUDIO_DRIVER_ALSA, 1, [ ])
-            SOURCES="$SOURCES $srcdir/src/audio/alsa/*.c"
-            EXTRA_CFLAGS="$EXTRA_CFLAGS $ALSA_CFLAGS"
-            if test x$have_loadso != xyes && \
-               test x$enable_alsa_shared = xyes; then
-                AC_MSG_WARN([You must have SDL_LoadObject() support for dynamic ALSA loading])
-            fi
-            if test x$have_loadso = xyes && \
-               test x$enable_alsa_shared = xyes && test x$alsa_lib != x; then
-                echo "-- dynamic libasound -> $alsa_lib"
-                AC_DEFINE_UNQUOTED(SDL_AUDIO_DRIVER_ALSA_DYNAMIC, "$alsa_lib", [ ])
-                SUMMARY_audio="${SUMMARY_audio} alsa(dynamic)"
-            else
-                EXTRA_LDFLAGS="$EXTRA_LDFLAGS $ALSA_LIBS"
-                SUMMARY_audio="${SUMMARY_audio} alsa"
-            fi
-            have_audio=yes
-        fi
-    fi
-}
-
 dnl Find JACK Audio
 CheckJACK()
 {
@@ -970,41 +931,6 @@ AS_HELP_STRING([--enable-jack-shared], [dynamically load JACK audio support [[de
     fi
 }
 
-dnl Find the ESD includes and libraries
-CheckESD()
-{
-    AC_ARG_ENABLE(esd,
-AS_HELP_STRING([--enable-esd], [support the Enlightened Sound Daemon [[default=yes]]]),
-                  , enable_esd=yes)
-    if test x$enable_audio = xyes -a x$enable_esd = xyes; then
-        AM_PATH_ESD(0.2.8, have_esd=yes, have_esd=no)
-        if test x$have_esd = xyes; then
-            AC_ARG_ENABLE(esd-shared,
-AS_HELP_STRING([--enable-esd-shared], [dynamically load ESD audio support [[default=yes]]]),
-                          , enable_esd_shared=yes)
-            esd_lib=[`find_lib "libesd.so.*" "$ESD_LIBS" | sed 's/.*\/\(.*\)/\1/; q'`]
-
-            AC_DEFINE(SDL_AUDIO_DRIVER_ESD, 1, [ ])
-            SOURCES="$SOURCES $srcdir/src/audio/esd/*.c"
-            EXTRA_CFLAGS="$EXTRA_CFLAGS $ESD_CFLAGS"
-            if test x$have_loadso != xyes && \
-               test x$enable_esd_shared = xyes; then
-                AC_MSG_WARN([You must have SDL_LoadObject() support for dynamic ESD loading])
-            fi
-            if test x$have_loadso = xyes && \
-               test x$enable_esd_shared = xyes && test x$esd_lib != x; then
-                echo "-- dynamic libesd -> $esd_lib"
-                AC_DEFINE_UNQUOTED(SDL_AUDIO_DRIVER_ESD_DYNAMIC, "$esd_lib", [ ])
-                SUMMARY_audio="${SUMMARY_audio} esd(dynamic)"
-            else
-                EXTRA_LDFLAGS="$EXTRA_LDFLAGS $ESD_LIBS"
-                SUMMARY_audio="${SUMMARY_audio} esd"
-            fi
-            have_audio=yes
-        fi
-    fi
-}
-
 dnl Find PulseAudio
 CheckPulseAudio()
 {
@@ -2978,17 +2904,6 @@ XINPUT_STATE_EX s1;
         esac
     fi
 
-    AC_CHECK_HEADER(mmdeviceapi.h, have_wasapi=yes)
-    if test x$have_wasapi = xyes; then
-        AC_DEFINE(HAVE_MMDEVICEAPI_H,1,[])
-    fi
-    AC_CHECK_HEADER(audioclient.h,,have_wasapi=no)
-    if test x$have_wasapi = xyes; then
-        AC_DEFINE(HAVE_AUDIOCLIENT_H,1,[])
-    fi
-
-    AC_CHECK_HEADER(endpointvolume.h,AC_DEFINE(HAVE_ENDPOINTVOLUME_H,1,[]))
-
     AC_ARG_ENABLE(wasapi,
 AS_HELP_STRING([--enable-wasapi], [use the Windows WASAPI audio driver [[default=yes]]]),
                                 , enable_wasapi=yes)
-- 
2.24.1

From 88899f0e05428df6e91b63cf0cb0e3da57b7a713 Mon Sep 17 00:00:00 2001
From: X512 <danger_mail@list.ru>
Date: Thu, 9 Jan 2020 03:15:38 +0900
Subject: Video: remove BDirectWindow, fix context management

---
 src/main/haiku/SDL_BApp.h           |  39 +--
 src/video/haiku/SDL_BWin.h          | 393 +++++++++++++++-------------
 src/video/haiku/SDL_bframebuffer.cc | 148 +----------
 src/video/haiku/SDL_bopengl.cc      |  39 ++-
 4 files changed, 271 insertions(+), 348 deletions(-)

diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index 6bdf6db..8510840 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -193,6 +193,10 @@ public:
     }
 
 #if SDL_VIDEO_OPENGL
+    BGLView *GetCurrentContext() {
+        return _current_context;
+    }
+    
     void SetCurrentContext(BGLView *newContext) {
         if(_current_context)
             _current_context->UnlockGL();
@@ -229,25 +233,22 @@ private:
         }
         win = GetSDLWindow(winID);
 
-		// Simple relative mode support for mouse.
-		if (SDL_GetMouse()->relative_mode) {
-			int winWidth, winHeight, winPosX, winPosY;
-			SDL_GetWindowSize(win, &winWidth, &winHeight);
-			SDL_GetWindowPosition(win, &winPosX, &winPosY);
-			int dx = x - (winWidth / 2);
-			int dy = y - (winHeight / 2);
-			SDL_SendMouseMotion(win, 0, SDL_GetMouse()->relative_mode, dx, dy);
-			set_mouse_position((winPosX + winWidth / 2), (winPosY + winHeight / 2));
-			if (!be_app->IsCursorHidden())
-				be_app->HideCursor();
-		} else {
-			SDL_SendMouseMotion(win, 0, 0, x, y);
-			if (SDL_ShowCursor(-1) && be_app->IsCursorHidden())
-				be_app->ShowCursor();
-		}
-
-        /* Tell the application that the mouse passed over, redraw needed */
-        HAIKU_UpdateWindowFramebuffer(NULL,win,NULL,-1);
+        // Simple relative mode support for mouse.
+        if (SDL_GetMouse()->relative_mode) {
+            int winWidth, winHeight, winPosX, winPosY;
+            SDL_GetWindowSize(win, &winWidth, &winHeight);
+            SDL_GetWindowPosition(win, &winPosX, &winPosY);
+            int dx = x - (winWidth / 2);
+            int dy = y - (winHeight / 2);
+            SDL_SendMouseMotion(win, 0, SDL_GetMouse()->relative_mode, dx, dy);
+            set_mouse_position((winPosX + winWidth / 2), (winPosY + winHeight / 2));
+            if (!be_app->IsCursorHidden())
+                be_app->HideCursor();
+        } else {
+            SDL_SendMouseMotion(win, 0, 0, x, y);
+            if (SDL_ShowCursor(-1) && be_app->IsCursorHidden())
+                be_app->ShowCursor();
+        }
     }
 
     void _HandleMouseButton(BMessage *msg) {
diff --git a/src/video/haiku/SDL_BWin.h b/src/video/haiku/SDL_BWin.h
index 9f79927..6d354d1 100644
--- a/src/video/haiku/SDL_BWin.h
+++ b/src/video/haiku/SDL_BWin.h
@@ -38,7 +38,6 @@ extern "C" {
 #include <stdio.h>
 #include <AppKit.h>
 #include <InterfaceKit.h>
-#include <game/DirectWindow.h>
 #if SDL_VIDEO_OPENGL
 #include <opengl/GLView.h>
 #endif
@@ -57,19 +56,47 @@ enum WinCommands {
     BWIN_SET_TITLE,
     BWIN_SET_BORDERED,
     BWIN_SET_RESIZABLE,
-    BWIN_FULLSCREEN
+    BWIN_FULLSCREEN,
+    BWIN_UPDATE_FRAMEBUFFER
 };
 
+// non-OpenGL framebuffer view
+class SDL_BView: public BView
+{
+public:
+    SDL_BView(BRect frame, const char* name, uint32 resizingMode)
+        : BView(frame, name, resizingMode, B_WILL_DRAW),
+        fBitmap(NULL)
+    {
+    }
+
+    void Draw(BRect dirty)
+    {
+        if (fBitmap != NULL)
+            DrawBitmap(fBitmap, B_ORIGIN);
+    }
+
+    void SetBitmap(BBitmap *bitmap)
+    {
+        fBitmap = bitmap;
+    }
+
+private:
+    BBitmap *fBitmap;
+};
 
-class SDL_BWin:public BDirectWindow
+class SDL_BWin: public BWindow
 {
   public:
     /* Constructor/Destructor */
     SDL_BWin(BRect bounds, window_look look, uint32 flags)
-        : BDirectWindow(bounds, "Untitled", look, B_NORMAL_WINDOW_FEEL, flags)
+        : BWindow(bounds, "Untitled", look, B_NORMAL_WINDOW_FEEL, flags)
     {
         _last_buttons = 0;
 
+        _cur_view = NULL;
+        _SDL_View = NULL;
+
 #if SDL_VIDEO_OPENGL
         _SDL_GLView = NULL;
         _gl_type = 0;
@@ -78,59 +105,84 @@ class SDL_BWin:public BDirectWindow
         _inhibit_resize = false;
         _mouse_focused = false;
         _prev_frame = NULL;
+        _fullscreen = NULL;
 
         /* Handle framebuffer stuff */
-        _connected = _connection_disabled = false;
-        _buffer_created = _buffer_dirty = false;
-        _trash_window_buffer = false;
         _buffer_locker = new BLocker();
         _bitmap = NULL;
-        _clips = NULL;
-        _num_clips = 0;
-
-#ifdef DRAWTHREAD
-        _draw_thread_id = spawn_thread(HAIKU_DrawThread, "drawing_thread",
-                            B_NORMAL_PRIORITY, (void*) this);
-        resume_thread(_draw_thread_id);
-#endif
     }
 
     virtual ~ SDL_BWin()
     {
         Lock();
-        _connection_disabled = true;
-        int32 result;
 
+        if (_SDL_View != NULL && _SDL_View != _cur_view) {
+            delete _SDL_View; _SDL_View = NULL;
+        }
 #if SDL_VIDEO_OPENGL
         if (_SDL_GLView) {
-            _SDL_GLView->UnlockGL();
-            RemoveChild(_SDL_GLView);   /* Why was this outside the if
-                                            statement before? */
+            if (((SDL_BApp*)be_app)->GetCurrentContext() == _SDL_GLView)
+                ((SDL_BApp*)be_app)->SetCurrentContext(NULL);
+            if (_SDL_GLView == _cur_view) RemoveChild(_SDL_GLView);
+            _SDL_GLView = NULL;
+            // _SDL_GLView deleted by HAIKU_GL_DeleteContext
         }
 
 #endif
         Unlock();
-#if SDL_VIDEO_OPENGL
-        if (_SDL_GLView) {
-            delete _SDL_GLView;
-        }
-#endif
 
         delete _prev_frame;
 
         /* Clean up framebuffer stuff */
         _buffer_locker->Lock();
-#ifdef DRAWTHREAD
-        wait_for_thread(_draw_thread_id, &result);
-#endif
-        free(_clips);
         delete _buffer_locker;
     }
 
+        void SetCurView(BView *view)
+        {
+            if (_cur_view != view) {
+                if (_cur_view != NULL) RemoveChild(_cur_view);
+                _cur_view = view;
+                // printf("Current view is: %p (%s)\n", _cur_view, _cur_view == NULL? "": typeid(*_cur_view).name());
+                if (_cur_view != NULL) AddChild(_cur_view);
+            }
+        }
+
+        void UpdateCurView()
+        {
+            if (_SDL_GLView != NULL) {
+                SetCurView(_SDL_GLView);
+            } else if (_SDL_View != NULL) {
+                SetCurView(_SDL_View);
+            } else {
+                SetCurView(NULL);
+            }
+        }
+
+    SDL_BView *CreateView() {
+        Lock();
+        if (_SDL_View == NULL) {
+            _SDL_View = new SDL_BView(Bounds(), "SDL View", B_FOLLOW_ALL_SIDES);
+            UpdateCurView();
+        }
+        Unlock();
+        return _SDL_View;
+    }
+
+    void RemoveView() {
+        Lock();
+        if(_SDL_View != NULL) {
+            SDL_BView *oldView = _SDL_View;
+            _SDL_View = NULL;
+            UpdateCurView();
+            delete oldView;
+        }
+        Unlock();
+    }
 
     /* * * * * OpenGL functionality * * * * */
 #if SDL_VIDEO_OPENGL
-    virtual BGLView *CreateGLView(Uint32 gl_flags) {
+    BGLView *CreateGLView(Uint32 gl_flags) {
         Lock();
         if (_SDL_GLView == NULL) {
             _SDL_GLView = new BGLView(Bounds(), "SDL GLView",
@@ -138,95 +190,33 @@ class SDL_BWin:public BDirectWindow
                                      (B_WILL_DRAW | B_FRAME_EVENTS),
                                      gl_flags);
             _gl_type = gl_flags;
+            UpdateCurView();
         }
-        AddChild(_SDL_GLView);
-        _SDL_GLView->EnableDirectMode(true);
-        _SDL_GLView->LockGL();  /* "New" GLViews are created */
         Unlock();
-        return (_SDL_GLView);
+        return _SDL_GLView;
     }
 
-    virtual void RemoveGLView() {
+    void RemoveGLView() {
         Lock();
-        if(_SDL_GLView) {
-            _SDL_GLView->UnlockGL();
-            RemoveChild(_SDL_GLView);
+        if(_SDL_GLView != NULL) {
+            if (((SDL_BApp*)be_app)->GetCurrentContext() == _SDL_GLView)
+                ((SDL_BApp*)be_app)->SetCurrentContext(NULL);
+            _SDL_GLView = NULL;
+            UpdateCurView();
+            // _SDL_GLView deleted by HAIKU_GL_DeleteContext
         }
         Unlock();
     }
 
-    virtual void SwapBuffers(void) {
-        _SDL_GLView->UnlockGL();
-        _SDL_GLView->LockGL();
+    void SwapBuffers(void) {
         _SDL_GLView->SwapBuffers();
     }
 #endif
 
-    /* * * * * Framebuffering* * * * */
-    virtual void DirectConnected(direct_buffer_info *info) {
-        if(!_connected && _connection_disabled) {
-            return;
-        }
-
-        /* Determine if the pixel buffer is usable after this update */
-        _trash_window_buffer =      _trash_window_buffer
-                                || ((info->buffer_state & B_BUFFER_RESIZED)
-                                || (info->buffer_state & B_BUFFER_RESET)
-                                || (info->driver_state == B_MODE_CHANGED));
-        LockBuffer();
-
-        switch(info->buffer_state & B_DIRECT_MODE_MASK) {
-        case B_DIRECT_START:
-            _connected = true;
-
-        case B_DIRECT_MODIFY:
-            if (info->clip_list_count > _num_clips)
-            {
-                if(_clips) {
-                    free(_clips);
-                    _clips = NULL;
-                }
-            }
-
-            _num_clips = info->clip_list_count;
-            if (_clips == NULL)
-                _clips = (clipping_rect *)malloc(_num_clips*sizeof(clipping_rect));
-            if(_clips) {
-                memcpy(_clips, info->clip_list,
-                    _num_clips*sizeof(clipping_rect));
-
-                _bits = (uint8*) info->bits;
-                _row_bytes = info->bytes_per_row;
-                _bounds = info->window_bounds;
-                _bytes_per_px = info->bits_per_pixel / 8;
-                _buffer_dirty = true;
-            }
-            break;
-
-        case B_DIRECT_STOP:
-            _connected = false;
-            break;
-        }
-#if SDL_VIDEO_OPENGL
-        if(_SDL_GLView) {
-            _SDL_GLView->DirectConnected(info);
-        }
-#endif
-
-
-        /* Call the base object directconnected */
-        BDirectWindow::DirectConnected(info);
-
-        UnlockBuffer();
-
-    }
-
-
-
 
     /* * * * * Event sending * * * * */
     /* Hook functions */
-    virtual void FrameMoved(BPoint origin) {
+    void FrameMoved(BPoint origin) {
         /* Post a message to the BApp so that it can handle the window event */
         BMessage msg(BAPP_WINDOW_MOVED);
         msg.AddInt32("window-x", (int)origin.x);
@@ -234,10 +224,10 @@ class SDL_BWin:public BDirectWindow
         _PostWindowEvent(msg);
 
         /* Perform normal hook operations */
-        BDirectWindow::FrameMoved(origin);
+        BWindow::FrameMoved(origin);
     }
 
-    virtual void FrameResized(float width, float height) {
+    void FrameResized(float width, float height) {
         /* Post a message to the BApp so that it can handle the window event */
         BMessage msg(BAPP_WINDOW_RESIZED);
 
@@ -246,10 +236,10 @@ class SDL_BWin:public BDirectWindow
         _PostWindowEvent(msg);
 
         /* Perform normal hook operations */
-        BDirectWindow::FrameResized(width, height);
+        BWindow::FrameResized(width, height);
     }
 
-    virtual bool QuitRequested() {
+    bool QuitRequested() {
         BMessage msg(BAPP_WINDOW_CLOSE_REQUESTED);
         _PostWindowEvent(msg);
 
@@ -257,13 +247,13 @@ class SDL_BWin:public BDirectWindow
         return false;
     }
 
-    virtual void WindowActivated(bool active) {
+    void WindowActivated(bool active) {
         BMessage msg(BAPP_KEYBOARD_FOCUS);  /* Mouse focus sold separately */
         msg.AddBool("focusGained", active);
         _PostWindowEvent(msg);
     }
 
-    virtual void Zoom(BPoint origin,
+    void Zoom(BPoint origin,
                 float width,
                 float height) {
         BMessage msg(BAPP_MAXIMIZE);    /* Closest thing to maximization Haiku has */
@@ -274,13 +264,13 @@ class SDL_BWin:public BDirectWindow
             _prev_frame = new BRect(Frame());
 
         /* Perform normal hook operations */
-        BDirectWindow::Zoom(origin, width, height);
+        BWindow::Zoom(origin, width, height);
     }
 
     /* Member functions */
-    virtual void Show() {
+    void Show() {
         while(IsHidden()) {
-            BDirectWindow::Show();
+            BWindow::Show();
         }
         _shown = true;
 
@@ -288,25 +278,33 @@ class SDL_BWin:public BDirectWindow
         _PostWindowEvent(msg);
     }
 
-    virtual void Hide() {
-        BDirectWindow::Hide();
+    void Hide() {
+        BWindow::Hide();
         _shown = false;
 
         BMessage msg(BAPP_HIDE);
         _PostWindowEvent(msg);
     }
 
-    virtual void Minimize(bool minimize) {
-        BDirectWindow::Minimize(minimize);
+    void Minimize(bool minimize) {
+        BWindow::Minimize(minimize);
         int32 minState = (minimize ? BAPP_MINIMIZE : BAPP_RESTORE);
 
         BMessage msg(minState);
         _PostWindowEvent(msg);
     }
 
+    void ScreenChanged(BRect screenFrame, color_space depth)
+    {
+        if (_fullscreen) {
+            MoveTo(screenFrame.left, screenFrame.top);
+            ResizeTo(screenFrame.Width(), screenFrame.Height());
+        }
+    }
+
 
     /* BView message interruption */
-    virtual void DispatchMessage(BMessage * msg, BHandler * target)
+    void DispatchMessage(BMessage * msg, BHandler * target)
     {
         BPoint where;   /* Used by mouse moved */
         int32 buttons;  /* Used for mouse button events */
@@ -355,7 +353,7 @@ class SDL_BWin:public BDirectWindow
                 }
             }
             break;
-            
+
         case B_UNMAPPED_KEY_DOWN:      /* modifier keys are unmapped */
             if (msg->FindInt32("key", &key) == B_OK) {
                 _KeyEvent((SDL_Scancode)key, NULL, 0, SDL_PRESSED);
@@ -375,15 +373,15 @@ class SDL_BWin:public BDirectWindow
                - CTRL+Q to close window (and other shortcuts)
                - PrintScreen to make screenshot into /boot/home
                - etc.. */
-            /* BDirectWindow::DispatchMessage(msg, target); */
+            /* BWindow::DispatchMessage(msg, target); */
             break;
         }
 
-        BDirectWindow::DispatchMessage(msg, target);
+        BWindow::DispatchMessage(msg, target);
     }
 
     /* Handle command messages */
-    virtual void MessageReceived(BMessage* message) {
+    void MessageReceived(BMessage* message) {
         switch (message->what) {
             /* Handle commands from SDL */
             case BWIN_SET_TITLE:
@@ -395,12 +393,18 @@ class SDL_BWin:public BDirectWindow
             case BWIN_RESIZE_WINDOW:
                 _ResizeTo(message);
                 break;
-            case BWIN_SET_BORDERED:
-                _SetBordered(message);
+            case BWIN_SET_BORDERED: {
+                bool bEnabled;
+                if (message->FindBool("window-border", &bEnabled) == B_OK)
+                    _SetBordered(bEnabled);
                 break;
-            case BWIN_SET_RESIZABLE:
-                _SetResizable(message);
+            }
+            case BWIN_SET_RESIZABLE: {
+                bool bEnabled;
+                if (message->FindBool("window-resizable", &bEnabled) == B_OK)
+                    _SetResizable(bEnabled);
                 break;
+            }
             case BWIN_SHOW_WINDOW:
                 Show();
                 break;
@@ -416,12 +420,31 @@ class SDL_BWin:public BDirectWindow
             case BWIN_RESTORE_WINDOW:
                 _Restore();
                 break;
-            case BWIN_FULLSCREEN:
-                _SetFullScreen(message);
+            case BWIN_FULLSCREEN: {
+                bool fullscreen;
+                if (message->FindBool("fullscreen", &fullscreen) == B_OK)
+                    _SetFullScreen(fullscreen);
                 break;
+            }
+            case BWIN_UPDATE_FRAMEBUFFER: {
+                BMessage* pendingMessage;
+                while ((pendingMessage
+                                = MessageQueue()->FindMessage(BWIN_UPDATE_FRAMEBUFFER, 0))) {
+                        MessageQueue()->RemoveMessage(pendingMessage);
+                        delete pendingMessage;
+                }
+                if (_bitmap != NULL) {
+                    if (_SDL_View != NULL && _cur_view == _SDL_View)
+                        _SDL_View->Draw(Bounds());
+                    else if (_SDL_GLView != NULL && _cur_view == _SDL_GLView) {
+                        _SDL_GLView->CopyPixelsIn(_bitmap, B_ORIGIN);
+                    }
+                }
+                break;
+            }
             default:
                 /* Perform normal message handling */
-                BDirectWindow::MessageReceived(message);
+                BWindow::MessageReceived(message);
                 break;
         }
 
@@ -432,19 +455,9 @@ class SDL_BWin:public BDirectWindow
     /* Accessor methods */
     bool IsShown() { return _shown; }
     int32 GetID() { return _id; }
-    uint32 GetRowBytes() { return _row_bytes; }
-    int32 GetFbX() { return _bounds.left; }
-    int32 GetFbY() { return _bounds.top; }
-    bool ConnectionEnabled() { return !_connection_disabled; }
-    bool Connected() { return _connected; }
-    clipping_rect *GetClips() { return _clips; }
-    int32 GetNumClips() { return _num_clips; }
-    uint8* GetBufferPx() { return _bits; }
-    int32 GetBytesPerPx() { return _bytes_per_px; }
-    bool CanTrashWindowBuffer() { return _trash_window_buffer; }
-    bool BufferExists() { return _buffer_created; }
-    bool BufferIsDirty() { return _buffer_dirty; }
     BBitmap *GetBitmap() { return _bitmap; }
+    BView *GetCurView() { return _cur_view; }
+    SDL_BView *GetView() { return _SDL_View; }
 #if SDL_VIDEO_OPENGL
     BGLView *GetGLView() { return _SDL_GLView; }
     Uint32 GetGLType() { return _gl_type; }
@@ -452,12 +465,9 @@ class SDL_BWin:public BDirectWindow
 
     /* Setter methods */
     void SetID(int32 id) { _id = id; }
-    void SetBufferExists(bool bufferExists) { _buffer_created = bufferExists; }
     void LockBuffer() { _buffer_locker->Lock(); }
     void UnlockBuffer() { _buffer_locker->Unlock(); }
-    void SetBufferDirty(bool bufferDirty) { _buffer_dirty = bufferDirty; }
-    void SetTrashBuffer(bool trash) { _trash_window_buffer = trash;     }
-    void SetBitmap(BBitmap *bitmap) { _bitmap = bitmap; }
+    void SetBitmap(BBitmap *bitmap) { _bitmap = bitmap; if (_SDL_View != NULL) _SDL_View->SetBitmap(bitmap); }
 
 
 private:
@@ -563,7 +573,10 @@ private:
         ) {
             return;
         }
-        MoveTo(x, y);
+        if (_fullscreen)
+            _non_fullscreen_frame.OffsetTo(x, y);
+        else
+            MoveTo(x, y);
     }
 
     void _ResizeTo(BMessage *msg) {
@@ -574,26 +587,29 @@ private:
         ) {
             return;
         }
-        ResizeTo(w, h);
+        if (_fullscreen) {
+            _non_fullscreen_frame.right = _non_fullscreen_frame.left + w;
+            _non_fullscreen_frame.bottom = _non_fullscreen_frame.top + h;
+        } else
+            ResizeTo(w, h);
     }
 
-    void _SetBordered(BMessage *msg) {
-        bool bEnabled;
-        if(msg->FindBool("window-border", &bEnabled) != B_OK) {
-            return;
-        }
-        SetLook(bEnabled ? B_TITLED_WINDOW_LOOK : B_NO_BORDER_WINDOW_LOOK);
+    void _SetBordered(bool bEnabled) {
+        if (_fullscreen)
+            _bordered = bEnabled;
+        else
+            SetLook(bEnabled ? B_TITLED_WINDOW_LOOK : B_NO_BORDER_WINDOW_LOOK);
     }
 
-    void _SetResizable(BMessage *msg) {
-        bool bEnabled;
-        if(msg->FindBool("window-resizable", &bEnabled) != B_OK) {
-            return;
-        }
-        if (bEnabled) {
-            SetFlags(Flags() & ~(B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
-        } else {
-            SetFlags(Flags() | (B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
+    void _SetResizable(bool bEnabled) {
+        if (_fullscreen)
+            _resizable = bEnabled;
+        else {
+            if (bEnabled) {
+                SetFlags(Flags() & ~(B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
+            } else {
+                SetFlags(Flags() | (B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
+            }
         }
     }
 
@@ -602,23 +618,42 @@ private:
             Minimize(false);
         } else if(IsHidden()) {
             Show();
+        } else if (_fullscreen) {
+
         } else if(_prev_frame != NULL) {    /* Zoomed */
             MoveTo(_prev_frame->left, _prev_frame->top);
             ResizeTo(_prev_frame->Width(), _prev_frame->Height());
         }
     }
 
-    void _SetFullScreen(BMessage *msg) {
-        bool fullscreen;
-        if(
-            msg->FindBool("fullscreen", &fullscreen) != B_OK
-        ) {
-            return;
+    void _SetFullScreen(bool fullscreen) {
+        if (fullscreen != _fullscreen) {
+            if (fullscreen) {
+                BScreen screen(this);
+                BRect screenFrame = screen.Frame();
+                printf("screen frame: "); screenFrame.PrintToStream(); printf("\n");
+                _bordered = Look() != B_NO_BORDER_WINDOW_LOOK;
+                _resizable = !(Flags() & B_NOT_RESIZABLE);
+                _non_fullscreen_frame = Frame();
+                _SetBordered(false);
+                _SetResizable(false);
+                MoveTo(screenFrame.left, screenFrame.top);
+                ResizeTo(screenFrame.Width(), screenFrame.Height());
+                _fullscreen = fullscreen;
+            } else {
+                _fullscreen = fullscreen;
+                MoveTo(_non_fullscreen_frame.left, _non_fullscreen_frame.top);
+                ResizeTo(_non_fullscreen_frame.Width(), _non_fullscreen_frame.Height());
+                _SetBordered(_bordered);
+                _SetResizable(_resizable);
+            }
         }
-        SetFullScreen(fullscreen);
     }
 
     /* Members */
+
+    BView* _cur_view;
+    SDL_BView* _SDL_View;
 #if SDL_VIDEO_OPENGL
     BGLView * _SDL_GLView;
     Uint32 _gl_type;
@@ -631,23 +666,15 @@ private:
     bool  _inhibit_resize;
 
     BRect *_prev_frame; /* Previous position and size of the window */
+    bool _fullscreen;
+    // valid only if fullscreen
+    BRect _non_fullscreen_frame;
+    bool _bordered;
+    bool _resizable;
 
     /* Framebuffer members */
-    bool            _connected,
-                    _connection_disabled,
-                    _buffer_created,
-                    _buffer_dirty,
-                    _trash_window_buffer;
-    uint8          *_bits;
-    uint32          _row_bytes;
-    clipping_rect   _bounds;
-    BLocker        *_buffer_locker;
-    clipping_rect  *_clips;
-    uint32          _num_clips;
-    int32           _bytes_per_px;
-    thread_id       _draw_thread_id;
-
-    BBitmap        *_bitmap;
+    BLocker *_buffer_locker;
+    BBitmap *_bitmap;
 };
 
 
diff --git a/src/video/haiku/SDL_bframebuffer.cc b/src/video/haiku/SDL_bframebuffer.cc
index de35dc6..e3d1136 100644
--- a/src/video/haiku/SDL_bframebuffer.cc
+++ b/src/video/haiku/SDL_bframebuffer.cc
@@ -35,10 +35,6 @@
 extern "C" {
 #endif
 
-#ifndef DRAWTHREAD
-static int32 HAIKU_UpdateOnce(SDL_Window *window);
-#endif
-
 static SDL_INLINE SDL_BWin *_ToBeWin(SDL_Window *window) {
     return ((SDL_BWin*)(window->driverdata));
 }
@@ -56,11 +52,11 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
         return -1;
     }
 
-    while(!bwin->Connected()) { snooze(100); }
-    
     /* Make sure we have exclusive access to frame buffer data */
     bwin->LockBuffer();
 
+    bwin->CreateView();
+
     /* format */
     display_mode bmode;
     bscreen.GetMode(&bmode);
@@ -76,7 +72,7 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
     bitmap = new BBitmap(bwin->Bounds(), (color_space)bmode.space,
             false,    /* Views not accepted */
             true);    /* Contiguous memory required */
-            
+
     if(bitmap->InitCheck() != B_OK) {
         delete bitmap;
         return SDL_SetError("Could not initialize back buffer!");
@@ -84,15 +80,13 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
 
 
     bwin->SetBitmap(bitmap);
-    
+
     /* Set the pixel pointer */
     *pixels = bitmap->Bits();
 
     /* pitch = width of window, in bytes */
     *pitch = bitmap->BytesPerRow();
 
-    bwin->SetBufferExists(true);
-    bwin->SetTrashBuffer(false);
     bwin->UnlockBuffer();
     return 0;
 }
@@ -106,149 +100,25 @@ int HAIKU_UpdateWindowFramebuffer(_THIS, SDL_Window * window,
 
     SDL_BWin *bwin = _ToBeWin(window);
 
-#ifdef DRAWTHREAD    
-    bwin->LockBuffer();
-    bwin->SetBufferDirty(true);
-    bwin->UnlockBuffer();
-#else
-    bwin->SetBufferDirty(true);
-    HAIKU_UpdateOnce(window);
-#endif
+    bwin->PostMessage(BWIN_UPDATE_FRAMEBUFFER);
 
     return 0;
 }
 
-int32 HAIKU_DrawThread(void *data) {
-    SDL_BWin *bwin = (SDL_BWin*)data;
-    
-    BScreen bscreen;
-    if(!bscreen.IsValid()) {
-        return -1;
-    }
-
-    while(bwin->ConnectionEnabled()) {
-        if( bwin->Connected() && bwin->BufferExists() && bwin->BufferIsDirty() ) {
-            bwin->LockBuffer();
-            BBitmap *bitmap = NULL;
-            bitmap = bwin->GetBitmap();
-            int32 windowPitch = bitmap->BytesPerRow();
-            int32 bufferPitch = bwin->GetRowBytes();
-            uint8 *windowpx;
-            uint8 *bufferpx;
-
-            int32 BPP = bwin->GetBytesPerPx();
-            int32 windowSub = bwin->GetFbX() * BPP +
-                          bwin->GetFbY() * windowPitch;
-            clipping_rect *clips = bwin->GetClips();
-            int32 numClips = bwin->GetNumClips();
-            int i, y;
-
-            /* Blit each clipping rectangle */
-            bscreen.WaitForRetrace();
-            for(i = 0; i < numClips; ++i) {
-                /* Get addresses of the start of each clipping rectangle */
-                int32 width = clips[i].right - clips[i].left + 1;
-                int32 height = clips[i].bottom - clips[i].top + 1;
-                bufferpx = bwin->GetBufferPx() + 
-                    clips[i].top * bufferPitch + clips[i].left * BPP;
-                windowpx = (uint8*)bitmap->Bits() + 
-                    clips[i].top * windowPitch + clips[i].left * BPP -
-                    windowSub;
-
-                /* Copy each row of pixels from the window buffer into the frame
-                   buffer */
-                for(y = 0; y < height; ++y)
-                {
-
-                    if(bwin->CanTrashWindowBuffer()) {
-                        goto escape;    /* Break out before the buffer is killed */
-                    }
-
-                    memcpy(bufferpx, windowpx, width * BPP);
-                    bufferpx += bufferPitch;
-                    windowpx += windowPitch;
-                }
-            }
-
-            bwin->SetBufferDirty(false);
-escape:
-            bwin->UnlockBuffer();
-        } else {
-            snooze(16000);
-        }
-    }
-    
-    return B_OK;
-}
-
 void HAIKU_DestroyWindowFramebuffer(_THIS, SDL_Window * window) {
     SDL_BWin *bwin = _ToBeWin(window);
-    
+
     bwin->LockBuffer();
-    
+
     /* Free and clear the window buffer */
     BBitmap *bitmap = bwin->GetBitmap();
     delete bitmap;
     bwin->SetBitmap(NULL);
-    bwin->SetBufferExists(false);
-    bwin->UnlockBuffer();
-}
 
+    bwin->RemoveView();
 
-/*
- * TODO:
- * This was written to test if certain errors were caused by threading issues.
- * The specific issues have since become rare enough that they may have been
- * solved, but I doubt it- they were pretty sporadic before now.
- */
-#ifndef DRAWTHREAD
-static int32 HAIKU_UpdateOnce(SDL_Window *window) {
-    SDL_BWin *bwin = _ToBeWin(window);
-    BScreen bscreen;
-    if(!bscreen.IsValid()) {
-        return -1;
-    }
-
-    if(bwin->ConnectionEnabled() && bwin->Connected()) {
-        bwin->LockBuffer();
-        int32 windowPitch = window->surface->pitch;
-        int32 bufferPitch = bwin->GetRowBytes();
-        uint8 *windowpx;
-        uint8 *bufferpx;
-
-        int32 BPP = bwin->GetBytesPerPx();
-        uint8 *windowBaseAddress = (uint8*)window->surface->pixels;
-        int32 windowSub = bwin->GetFbX() * BPP +
-                          bwin->GetFbY() * windowPitch;
-        clipping_rect *clips = bwin->GetClips();
-        int32 numClips = bwin->GetNumClips();
-        int i, y;
-
-        /* Blit each clipping rectangle */
-        bscreen.WaitForRetrace();
-        for(i = 0; i < numClips; ++i) {
-            /* Get addresses of the start of each clipping rectangle */
-            int32 width = clips[i].right - clips[i].left + 1;
-            int32 height = clips[i].bottom - clips[i].top + 1;
-            bufferpx = bwin->GetBufferPx() + 
-                clips[i].top * bufferPitch + clips[i].left * BPP;
-            windowpx = windowBaseAddress + 
-                clips[i].top * windowPitch + clips[i].left * BPP - windowSub;
-
-            /* Copy each row of pixels from the window buffer into the frame
-               buffer */
-            for(y = 0; y < height; ++y)
-            {
-                memcpy(bufferpx, windowpx, width * BPP);
-                bufferpx += bufferPitch;
-                windowpx += windowPitch;
-            }
-        }
-        bwin->UnlockBuffer();
-    }
-    return 0;
+    bwin->UnlockBuffer();
 }
-#endif
 
 #ifdef __cplusplus
 }
diff --git a/src/video/haiku/SDL_bopengl.cc b/src/video/haiku/SDL_bopengl.cc
index 44b21fe..179897b 100644
--- a/src/video/haiku/SDL_bopengl.cc
+++ b/src/video/haiku/SDL_bopengl.cc
@@ -30,6 +30,11 @@
 #include "SDL_BWin.h"
 #include "../../main/haiku/SDL_BApp.h"
 
+// TODO: remove when mesa package will be updated
+#ifndef BGL_SHARE_CONTEXT
+#define BGL_SHARE_CONTEXT 1024
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -84,16 +89,21 @@ void *HAIKU_GL_GetProcAddress(_THIS, const char *proc)
 }
 
 
-
-
 int HAIKU_GL_SwapWindow(_THIS, SDL_Window * window) {
     _ToBeWin(window)->SwapBuffers();
     return 0;
 }
 
 int HAIKU_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context) {
-    SDL_BWin* win = (SDL_BWin*)context;
-    _GetBeApp()->SetCurrentContext(win ? win->GetGLView() : NULL);
+    BGLView* glView = (BGLView*)context;
+    // printf("HAIKU_GL_MakeCurrent(%llx), win = %llx, thread = %d\n", (uint64)context, (uint64)window, find_thread(NULL));
+    if (glView != NULL) {
+        if ((glView->Window() == NULL) || (window == NULL) || (_ToBeWin(window)->GetGLView() != glView)) {
+            SDL_SetError("MakeCurrent failed");
+            return -1;
+        }
+    }
+    _GetBeApp()->SetCurrentContext(glView);
     return 0;
 }
 
@@ -102,6 +112,11 @@ SDL_GLContext HAIKU_GL_CreateContext(_THIS, SDL_Window * window) {
     /* FIXME: Not sure what flags should be included here; may want to have
        most of them */
     SDL_BWin *bwin = _ToBeWin(window);
+    // printf("HAIKU_GL_CreateContext, win = %llx, thread = %d\n", (uint64)window, find_thread(NULL));
+    if (bwin->GetGLView() != NULL) {
+        SDL_SetError("Context already creaded");
+        return NULL;
+    }
     Uint32 gl_flags = BGL_RGB;
     if (_this->gl_config.alpha_size) {
         gl_flags |= BGL_ALPHA;
@@ -123,13 +138,23 @@ SDL_GLContext HAIKU_GL_CreateContext(_THIS, SDL_Window * window) {
             _this->gl_config.accum_alpha_size) {
         gl_flags |= BGL_ACCUM;
     }
+    if (_this->gl_config.share_with_current_context) {
+        gl_flags |= BGL_SHARE_CONTEXT;
+    }
     bwin->CreateGLView(gl_flags);
-    return (SDL_GLContext)(bwin);
+    _GetBeApp()->SetCurrentContext(bwin->GetGLView());
+    return (SDL_GLContext)(bwin->GetGLView());
 }
 
 void HAIKU_GL_DeleteContext(_THIS, SDL_GLContext context) {
-    /* Currently, automatically unlocks the view */
-    ((SDL_BWin*)context)->RemoveGLView();
+    // printf("HAIKU_GL_DeleteContext(%llx), thread = %d\n", (uint64)context, find_thread(NULL));
+    BGLView* glView = (BGLView*)context;
+    SDL_BWin *bwin = (SDL_BWin*)glView->Window();
+    if (bwin == NULL) {
+        delete glView;
+    } else {
+        bwin->RemoveGLView();
+    }
 }
 
 
-- 
2.24.1

